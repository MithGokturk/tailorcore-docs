## Table of Contents

1. [Introduction](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#introduction)
2. [Overall Directory Structure](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#overall-directory-structure)
3. [Backend Architecture (src/backend/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#backend-architecture)
4. [Frontend Architecture (src/frontend/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#frontend-architecture)
5. [Mobile Architecture (src/mobile/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#mobile-architecture)
6. [Babylon Runtime (src/babylon/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#babylon-runtime)
7. [Unity Tooling (src/unity/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#unity-tooling)
8. [Test Architecture (tests/)](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#test-architecture)
9. [Guidelines for AI Code Generation](https://claude.ai/chat/30631e7b-99c2-4d61-8f91-aa2e553dd8b6#guidelines-for-ai-code-generation)

## Introduction

This document defines the comprehensive directory structure for the TailorCore MVP project. It serves as the authoritative reference for all code organization, delineating clear boundaries between system components while ensuring proper separation of concerns. The structure adheres to Clean Architecture principles in the backend and follows component-based design in the frontend.

The TailorCore MVP is a local-only virtual fitting application with two bounded contexts (measurement and garment) that enables users to create avatars based on body measurements and try on 3D garments with visual feedback based on anchor measurement comparisons.

## Overall Directory Structure

```
TailorCore/
├── src/
│   ├── backend/              # Backend Clean Architecture layers
│   ├── frontend/             # React + Zustand + Babylon.js integration
│   ├── mobile/               # Android native (Kotlin + Jetpack Compose)
│   ├── babylon/              # Reusable Babylon.js runtime modules
│   └── unity/                # Unity garment validation tools
├── tests/                    # Test suites mirroring src/ structure
└── docs/                     # Documentation files
```

## Backend Architecture

The backend follows Clean Architecture principles with concentric layers and dependencies pointing inward.

```
src/backend/
├── domain/                   # Core business logic and rules
│   ├── common/               # Shared domain components
│   ├── measurement/          # Measurement bounded context
│   └── garment/              # Garment bounded context
├── application/              # Use cases and orchestration
│   ├── common/               # Shared application components
│   ├── measurement/          # Measurement use cases
│   └── garment/              # Garment use cases
├── infrastructure/           # Technical implementations
│   ├── persistence/          # Data storage implementations
│   ├── services/             # External service implementations
│   └── simulation/           # Visualization and rendering implementations
└── api/                      # API controllers and models
    ├── controllers/          # Request handlers
    ├── models/               # API input/output models
    └── middleware/           # Request processing components
```

### src/backend/domain/

**Purpose**: Contains the core business logic and rules of the application, including entities, value objects, domain events, and interfaces. This layer is independent of any external frameworks or technologies.

#### src/backend/domain/common/

```
domain/common/
├── enums/                    # Domain enumerations
│   ├── GenderType.cs         # Gender enumeration (Male/Female)
│   ├── MeasurementCategory.cs # Measurement point categories
│   ├── GarmentType.cs        # Types of garments
│   └── FitStatus.cs          # Fit quality status (Good/Tight/Loose)
├── exceptions/               # Domain-specific exceptions
│   ├── DomainException.cs    # Base exception class
│   ├── InvalidMeasurementException.cs  # Measurement validation failures
│   └── IncompatibleGarmentException.cs # Garment compatibility issues
├── interfaces/               # Core domain interfaces
│   ├── IAggregateRoot.cs     # Aggregate root marker interface
│   └── IDomainEvent.cs       # Domain event interface
└── valueobjects/             # Immutable value objects
    ├── Coordinate.cs         # 3D coordinate (X, Y, Z)
    ├── Dimension.cs          # Physical dimensions
    └── BodyMetrics.cs        # Derived body measurements
```

**Justification**: Domain components must be isolated from external concerns to ensure the business rules remain pure and independent of implementation details. These components form the stable core of the system.

**MVP Relevance**: All files in the domain layer are immediately required for the MVP as they define the core business concepts.

**Violation if Misplaced**: Placing domain logic elsewhere would create circular dependencies, mix business rules with technical concerns, and reduce testability.

**AI Usability**: When generating files in the domain layer, focus on pure business logic without references to external frameworks, databases, or UI concerns. Entities should encapsulate business rules and enforce invariants.

#### src/backend/domain/measurement/

```
domain/measurement/
├── entities/                 # Measurement entities
│   ├── MeasurementPoint.cs   # Individual body measurement point
│   ├── Avatar.cs             # User's virtual mannequin
│   └── MeasurementSet.cs     # Collection of measurements
├── events/                   # Measurement domain events
│   ├── AvatarCreatedEvent.cs # Event raised when avatar created
│   └── MeasurementsUpdatedEvent.cs # Event for measurement changes
├── interfaces/               # Measurement interfaces
│   ├── IMeasurementService.cs # Measurement calculation interface
│   └── IAvatarRepository.cs  # Avatar data access interface
└── services/                 # Measurement domain services
    ├── BodyCalculationService.cs # BMI and derivative calculations
    └── AvatarGenerationService.cs # Avatar model generation logic
```

**Justification**: Measurement-specific domain components are grouped in a bounded context to maintain cohesion and clear boundaries. These components handle the core avatar measurement functionality.

**MVP Relevance**: All measurement domain components are immediately required for the MVP's avatar creation functionality.

**Violation if Misplaced**: Mixing measurement domain concepts with other contexts would blur domain boundaries and create inappropriate dependencies.

**AI Usability**: Generate measurement entities with rich domain behavior, ensuring they enforce business rules like valid measurement ranges. Interfaces should define contracts without implementation details.

#### src/backend/domain/garment/

```
domain/garment/
├── entities/                 # Garment entities
│   ├── Garment.cs            # Clothing item with metadata
│   ├── GarmentAnchor.cs      # Attachment points with expected measurements
│   └── LayeringRule.cs       # Rules for garment combinations
├── events/                   # Garment domain events
│   ├── GarmentUploadedEvent.cs # Event for new garment upload
│   ├── GarmentPublishedEvent.cs # Event for garment publication
│   └── GarmentAppliedEvent.cs # Event when garment applied to avatar
├── interfaces/               # Garment interfaces
│   ├── IGarmentRepository.cs # Garment data access interface
│   └── IFittingService.cs    # Garment fitting interface
└── services/                 # Garment domain services
    ├── FittingCalculationService.cs # Fit quality calculation based on measurements
    └── LayeringValidationService.cs # Garment layering validation
```

**Justification**: Garment-specific domain components are grouped in a bounded context to maintain cohesion and clear boundaries. These components handle the core garment functionality.

**MVP Relevance**: All garment domain components are immediately required for the MVP's garment fitting functionality, with `GarmentAnchor.cs` being crucial for anchor-based fit evaluation.

**Violation if Misplaced**: Mixing garment domain concepts with other contexts would blur domain boundaries and create inappropriate dependencies.

**AI Usability**: Generate garment entities with rich domain behavior, ensuring they enforce business rules like valid anchor points and layering rules. GarmentAnchor must include ExpectedValue properties for measurement comparison.

### src/backend/application/

**Purpose**: Orchestrates the flow of data and actions between the domain layer and external components. Implements use cases by coordinating domain entities and services.

#### src/backend/application/common/

```
application/common/
├── behaviors/                # Cross-cutting behaviors
│   ├── LoggingBehavior.cs    # Command/query logging
│   ├── ValidationBehavior.cs # Input validation
│   └── DomainEventDispatchBehavior.cs # Event dispatch handling
├── interfaces/               # Application interfaces
│   ├── ICommand.cs           # Command pattern interface
│   ├── ICommandHandler.cs    # Command handler interface
│   ├── IQuery.cs             # Query pattern interface
│   ├── IQueryHandler.cs      # Query handler interface
│   └── IEventDispatcher.cs   # Event dispatcher interface
└── exceptions/               # Application exceptions
    ├── ApplicationException.cs # Base application exception
    └── ValidationException.cs # Input validation failures
```

**Justification**: Common application components provide cross-cutting functionality and define patterns used throughout the application layer. They ensure consistent handling of commands, queries, and events.

**MVP Relevance**: All common application components are immediately required for the MVP to ensure consistent orchestration patterns.

**Violation if Misplaced**: Scattering these components would lead to inconsistent implementation of architectural patterns and duplicate code.

**AI Usability**: Generate application behaviors and interfaces that support the CQRS pattern without adding business logic. These components should focus on orchestration and cross-cutting concerns.

#### src/backend/application/measurement/

```
application/measurement/
├── commands/                 # Measurement commands
│   ├── CreateAvatarCommand.cs # Command to create avatar
│   ├── CreateAvatarCommandHandler.cs # Handler for avatar creation
│   ├── UpdateAvatarMeasurementsCommand.cs # Command to update measurements
│   └── UpdateAvatarMeasurementsCommandHandler.cs # Handler for updates
├── queries/                  # Measurement queries
│   ├── GetMeasurementsByGenderQuery.cs # Query for standard measurements
│   ├── GetMeasurementsByGenderQueryHandler.cs # Handler for measurements query
│   ├── GetAvatarByIdQuery.cs # Query for avatar by ID
│   └── GetAvatarByIdQueryHandler.cs # Handler for avatar query
├── dtos/                     # Data transfer objects
│   ├── AvatarDto.cs          # Avatar data projection
│   └── MeasurementPointDto.cs # Measurement point projection
└── interfaces/               # Application service interfaces
    ├── IAvatarService.cs     # Avatar operations interface
    └── IMeasurementService.cs # Measurement operations interface
```

**Justification**: Measurement application components implement use cases related to avatars and measurements, orchestrating domain entities and services to fulfill specific application needs.

**MVP Relevance**: All measurement application components are immediately required for the MVP's avatar creation and management functionality.

**Violation if Misplaced**: Moving these components would mix use case implementation with domain logic or external concerns, reducing clarity and maintainability.

**AI Usability**: Generate command and query handlers that coordinate domain operations without implementing business rules. DTOs should be focused projections of domain entities for specific use cases.

#### src/backend/application/garment/

```
application/garment/
├── commands/                 # Garment commands
│   ├── UploadGarmentCommand.cs # Command to upload garment
│   ├── UploadGarmentCommandHandler.cs # Handler for garment upload
│   ├── PublishGarmentCommand.cs # Command to publish garment
│   ├── PublishGarmentCommandHandler.cs # Handler for publication
│   ├── ApplyGarmentToAvatarCommand.cs # Command to apply garment
│   └── ApplyGarmentToAvatarCommandHandler.cs # Handler for applying garment
├── queries/                  # Garment queries
│   ├── GetGarmentsByCategoryQuery.cs # Query for filtered garments
│   ├── GetGarmentsByCategoryQueryHandler.cs # Handler for category query
│   ├── GetGarmentByIdQuery.cs # Query for garment by ID
│   ├── GetGarmentByIdQueryHandler.cs # Handler for garment query
│   ├── GetPublishedGarmentsQuery.cs # Query for published garments
│   └── GetPublishedGarmentsQueryHandler.cs # Handler for published query
├── dtos/                     # Data transfer objects
│   ├── GarmentDto.cs         # Garment data projection
│   ├── GarmentAnchorDto.cs   # Anchor point with expected measurement projection
│   └── FittingResultDto.cs   # Garment fitting results with fit status
└── interfaces/               # Application service interfaces
    ├── IGarmentService.cs    # Garment operations interface
    └── IFittingApplicationService.cs # Fitting operations interface
```

**Justification**: Garment application components implement use cases related to garments and fitting, orchestrating domain entities and services to fulfill specific application needs.

**MVP Relevance**: All garment application components are immediately required for the MVP's garment management and fitting functionality, with `GarmentAnchorDto.cs` being crucial for measurement-based fit evaluation.

**Violation if Misplaced**: Moving these components would mix use case implementation with domain logic or external concerns, reducing clarity and maintainability.

**AI Usability**: Generate command and query handlers that coordinate domain operations without implementing business rules. Handlers should focus on orchestration between repositories, domain services, and event dispatching.

### src/backend/infrastructure/

**Purpose**: Provides concrete implementations of interfaces defined in the domain and application layers, including persistence, file handling, and external services.

#### src/backend/infrastructure/persistence/

```
infrastructure/persistence/
├── contexts/                 # Database contexts
│   └── TailorCoreDbContext.cs # Entity Framework context
├── repositories/             # Repository implementations
│   ├── MeasurementRepository.cs # Measurement data access
│   ├── AvatarRepository.cs   # Avatar data access
│   └── GarmentRepository.cs  # Garment data access
├── configurations/           # Entity configurations
│   ├── MeasurementPointConfiguration.cs # Measurement mapping
│   ├── AvatarConfiguration.cs # Avatar mapping
│   ├── GarmentConfiguration.cs # Garment mapping
│   └── GarmentAnchorConfiguration.cs # Anchor mapping with expected measurements
└── migrations/               # Database migrations
    └── InitialMigration.cs   # Initial schema creation
```

**Justification**: Persistence components implement data access interfaces defined in the domain layer, isolating database concerns from business logic.

**MVP Relevance**: All persistence components are immediately required for the MVP to store and retrieve data, including the crucial anchor measurements via `GarmentAnchorConfiguration.cs`.

**Violation if Misplaced**: Moving these components would mix persistence concerns with business logic or API handling, violating Clean Architecture principles.

**AI Usability**: Generate repository implementations that honor the interfaces defined in the domain layer. Database-specific code should be isolated in these implementations to maintain persistence ignorance in the domain.

#### src/backend/infrastructure/services/

```
infrastructure/services/
├── file/                     # File handling services
│   ├── GlbFileService.cs     # GLB file operations
│   └── LocalFileStorage.cs   # Local file system storage
├── rendering/                # Rendering services
│   ├── BabylonRenderingService.cs # Babylon.js integration
│   └── UnityRenderingService.cs # Unity integration
└── events/                   # Event handling
    └── DomainEventDispatcher.cs # Domain event distribution
```

**Justification**: Service components implement technical capabilities required by the application, such as file handling and rendering integrations.

**MVP Relevance**: All file and rendering services are immediately required for the MVP to handle GLB files and 3D visualization.

**Violation if Misplaced**: Moving these components would mix technical implementation details with business logic or API concerns.

**AI Usability**: Generate service implementations that focus on technical concerns while adhering to interfaces defined in the application layer. Avoid adding business rules to these components.

#### src/backend/infrastructure/simulation/

```
infrastructure/simulation/
├── avatar/                   # Avatar simulation
│   ├── AvatarSimulationService.cs # Avatar visualization
│   └── AvatarAnimationService.cs # Avatar animations
└── fitting/                  # Garment fitting simulation
    ├── FittingSimulationService.cs # Garment visualization with anchors
    └── FittingFeedbackService.cs # Fit status visualization (Green/Yellow/Red)
```

**Justification**: Simulation components implement the technical aspects of visualizing avatars and garments, translating business concepts into renderable representations and providing visual feedback on fit quality.

**MVP Relevance**: All simulation components are immediately required for the MVP's visualization functionality, particularly `FittingFeedbackService.cs` for anchor-based fit evaluation visualization.

**Violation if Misplaced**: Moving these components would mix technical visualization concerns with business rules or API handling.

**AI Usability**: Generate simulation services that focus on translating domain concepts into visual representations without adding business rules. FittingFeedbackService should implement the color-coded visualization based on measurement comparisons.

### src/backend/api/

**Purpose**: Provides the interface for external clients to interact with the application, handling HTTP requests and responses.

#### src/backend/api/controllers/

```
api/controllers/
├── measurement/              # Measurement controllers
│   ├── AvatarController.cs   # Avatar operations
│   └── MeasurementController.cs # Measurement operations
└── garment/                  # Garment controllers
    ├── GarmentController.cs  # User garment operations
    └── AdminGarmentController.cs # Admin garment operations
```

**Justification**: Controllers handle HTTP requests and responses, mapping between external inputs and application commands/queries. They're separated by domain context for clarity.

**MVP Relevance**: All controllers are immediately required for the MVP to enable API access to the application's functionality.

**Violation if Misplaced**: Moving controllers would mix HTTP concerns with business logic or persistence details.

**AI Usability**: Generate thin controllers that only handle HTTP concerns, mapping requests to application commands/queries and responses from application DTOs. Controllers should not contain business logic.

#### src/backend/api/models/

```
api/models/
├── requests/                 # API request models
│   ├── CreateAvatarRequest.cs # Avatar creation input
│   ├── UploadGarmentRequest.cs # Garment upload input with anchor measurements
│   └── ApplyGarmentRequest.cs # Garment application input
└── responses/                # API response models
    ├── AvatarResponse.cs     # Avatar data response
    ├── GarmentResponse.cs    # Garment data response
    └── FittingResponse.cs    # Fitting results response with fit status
```

**Justification**: API models define the contract between the API and its clients, ensuring consistent data formats for requests and responses.

**MVP Relevance**: All API models are immediately required for the MVP to ensure proper data exchange with clients, with `UploadGarmentRequest.cs` and `FittingResponse.cs` being crucial for anchor-based measurements.

**Violation if Misplaced**: Mixing API models with application DTOs or domain entities would create inappropriate dependencies.

**AI Usability**: Generate request and response models that focus on the API contract without business logic. `FittingResponse.cs` should include fit status data based on measurement comparisons.

#### src/backend/api/middleware/

```
api/middleware/
├── ErrorHandlingMiddleware.cs # Global error handling
└── SimulatedAuthMiddleware.cs # Mock authentication
```

**Justification**: Middleware components handle cross-cutting concerns for all API requests, such as error handling and simplified authentication for the MVP.

**MVP Relevance**: Both middleware components are immediately required for the MVP to ensure consistent error handling and simulated authentication.

**Violation if Misplaced**: Moving middleware would scatter cross-cutting concerns across the application.

**AI Usability**: Generate middleware that focuses on HTTP pipeline concerns without business logic. These components should handle technical aspects of request processing.

## Frontend Architecture

The frontend follows a component-based architecture using React with Zustand for state management and Babylon.js for 3D visualization.

```
src/frontend/
├── components/               # Reusable UI components
│   ├── avatar/               # Avatar-related components
│   ├── garment/              # Garment-related components
│   ├── layout/               # Layout components
│   └── ui/                   # Basic UI components
├── pages/                    # Page components
├── canvas/                   # Babylon.js integration
│   ├── components/           # Canvas React components
│   ├── controllers/          # Scene controllers
│   ├── loaders/              # Asset loaders
│   ├── materials/            # Material definitions
│   └── utils/                # Canvas utilities
├── services/                 # API integration
├── state/                    # Zustand state stores
├── hooks/                    # Custom React hooks
├── utils/                    # Utility functions
├── styles/                   # Global styles
├── types/                    # TypeScript definitions
├── index.tsx                 # Application entry point
├── App.tsx                   # Root component
└── vite-env.d.ts             # Vite type definitions
```

### src/frontend/components/

**Purpose**: Contains reusable UI components organized by domain and function.

#### src/frontend/components/avatar/

```
components/avatar/
├── AvatarCreationForm.tsx    # Form for inputting avatar metrics
├── AvatarMeasurements.tsx    # Display of avatar measurements
└── FitFeedback.tsx           # Visualization of garment fit quality
```

**Justification**: Avatar components encapsulate UI related to avatar creation and measurement display. They're grouped to maintain cohesion and reusability.

**MVP Relevance**: All avatar components are immediately required for the MVP's avatar creation and fitting feedback functionality, with `FitFeedback.tsx` being crucial for visualizing anchor-based fit evaluation.

**Violation if Misplaced**: Moving these components would mix avatar-specific UI with other concerns, reducing clarity and reusability.

**AI Usability**: Generate avatar components that focus on UI presentation and user interaction, delegating business logic to hooks and state stores. `FitFeedback.tsx` should visualize fit status based on anchor measurement comparisons.

#### src/frontend/components/garment/

```
components/garment/
├── GarmentCard.tsx           # Individual garment display
├── GarmentGrid.tsx           # Grid layout for garments
├── GarmentSelector.tsx       # Garment browsing with filters
└── GarmentAnchorVisualizer.tsx # Visualization of anchor points
```

**Justification**: Garment components encapsulate UI related to garment selection and display. They're grouped to maintain cohesion and reusability.

**MVP Relevance**: All garment components are immediately required for the MVP's garment selection functionality, with `GarmentAnchorVisualizer.tsx` providing visual feedback on anchor points.

**Violation if Misplaced**: Moving these components would mix garment-specific UI with other concerns, reducing clarity and reusability.

**AI Usability**: Generate garment components that focus on UI presentation and user interaction, delegating business logic to hooks and state stores. These components should handle garment selection and filtering.

#### src/frontend/components/layout/

```
components/layout/
├── AppLayout.tsx             # Main application layout
├── ControlsPanel.tsx         # 3D view control panel
└── Header.tsx                # Application header
```

**Justification**: Layout components provide structural organization for the application UI. They're separated to maintain a clear structural hierarchy.

**MVP Relevance**: All layout components are immediately required for the MVP's basic UI structure.

**Violation if Misplaced**: Moving these components would break the structural organization of the UI.

**AI Usability**: Generate layout components that focus on UI structure and organization, using Tailwind for responsive layouts. These components should provide consistent structure across the application.

#### src/frontend/components/ui/

```
components/ui/
├── Button.tsx                # Reusable button
├── ColorBadge.tsx            # Status indicator for fit feedback
├── Input.tsx                 # Form input
├── LoadingIndicator.tsx      # Loading spinner
└── Panel.tsx                 # Content panel
```

**Justification**: UI components provide basic building blocks for the user interface. They're separated to ensure consistency and reusability.

**MVP Relevance**: All UI components are immediately required for the MVP to maintain consistent UI elements, with `ColorBadge.tsx` being important for fit status visualization.

**Violation if Misplaced**: Moving these components would scatter basic UI elements across the application, reducing consistency and increasing duplication.

**AI Usability**: Generate UI components that focus on fundamental UI elements with consistent styling using Tailwind. `ColorBadge.tsx` should support the three fit status colors (Green/Yellow/Red).

### src/frontend/canvas/

**Purpose**: Contains Babylon.js integration components for 3D visualization, separated by function.

#### src/frontend/canvas/materials/

```
canvas/materials/
├── fitFeedbackMaterial.ts    # Fit quality visualization (Green/Yellow/Red)
└── defaultMaterials.ts       # Standard model materials
```

**Justification**: Material definitions handle the visual appearance of 3D objects, separated to encapsulate material-specific logic.

**MVP Relevance**: All material definitions are immediately required for the MVP's visual feedback functionality, with `fitFeedbackMaterial.ts` being crucial for anchor-based fit visualization.

**Violation if Misplaced**: Moving material definitions would mix visual appearance concerns with structural or interaction concerns.

**AI Usability**: Generate material definitions that focus on creating visually appropriate materials for different use cases, particularly for color-coded feedback based on anchor measurement comparisons.

## Mobile Architecture

The mobile architecture follows Android native patterns with Kotlin and Jetpack Compose, embedding Babylon.js for 3D visualization through WebView.

```
src/mobile/
├── app/                      # Application core components
│   ├── TailorCoreApp.kt      # Application class
│   ├── MainActivity.kt       # Main entry point activity
│   └── di/                   # Dependency injection setup
│       └── AppModule.kt      # Application-level dependencies
├── ui/                       # User interface components
│   ├── theme/                # Theme definitions
│   │   ├── Color.kt          # Color palette
│   │   ├── Theme.kt          # App theme definition
│   │   └── Typography.kt     # Text styles
│   ├── components/           # Reusable UI components
│   │   ├── Button.kt         # Custom button component
│   │   ├── InputField.kt     # Measurement input field
│   │   ├── GarmentCard.kt    # Garment display card
│   │   └── LoadingIndicator.kt # Loading state visualization
│   └── screens/              # Application screens
│       ├── login/            # Login screen components
│       │   └── LoginScreen.kt # User type selection
│       ├── avatar/           # Avatar creation screens
│       │   ├── MeasurementScreen.kt # Measurement input form
│       │   └── AvatarPreviewScreen.kt # Generated avatar preview
│       ├── garment/          # Garment selection screens
│       │   ├── GarmentListScreen.kt # Garment browsing
│       │   └── GarmentDetailScreen.kt # Individual garment details
│       └── fitting/          # Fitting visualization screens
│           └── FittingScreen.kt # Combined avatar and garment view with fit feedback
├── network/                  # API communication
│   ├── api/                  # REST API interfaces
│   │   ├── MeasurementApi.kt # Avatar measurements endpoints
│   │   └── GarmentApi.kt     # Garment data endpoints
│   ├── models/               # Network data models
│   │   ├── MeasurementRequest.kt # Measurement input data
│   │   ├── GarmentAnchor.kt  # Anchor with expected measurements
│   │   └── GarmentResponse.kt # Garment response structure
│   └── repository/           # Data repositories
│       ├── MeasurementRepository.kt # Avatar data operations
│       └── GarmentRepository.kt # Garment data operations
├── domain/                   # Domain layer for business logic
│   ├── model/                # Domain models
│   │   ├── Avatar.kt         # User avatar representation
│   │   ├── Garment.kt        # Clothing item representation
│   │   └── FitResult.kt      # Garment fitting results with status
│   ├── usecase/              # Application use cases
│   │   ├── CreateAvatarUseCase.kt # Avatar creation logic
│   │   └── ApplyGarmentUseCase.kt # Garment application logic with fit evaluation
│   └── mapper/               # Object mapping utilities
│       └── ResponseMappers.kt # Network to domain mappings
├── webview/                  # Babylon.js WebView integration
│   ├── BabylonView.kt        # WebView wrapper component
│   ├── BabylonBridge.kt      # JavaScript bridge interface
│   ├── assets/               # Web assets for Babylon
│   │   ├── babylon-runner.html # WebView HTML container
│   │   ├── babylon-runner.js # WebView JavaScript controller
│   │   └── styles.css        # WebView styling
│   └── controller/           # WebView control logic
│       ├── AvatarController.kt # Avatar visualization control
│       └── GarmentController.kt # Garment visualization with fit feedback
└── util/                     # Utility functions
    ├── Constants.kt          # Application constants
    ├── Extensions.kt         # Kotlin extension functions
    └── BitmapUtils.kt        # Image processing utilities
```

### src/mobile/app/

**Purpose**: Contains the core application components that initialize and configure the Android application.

**Justification**: Android applications require standard entry points and configuration components. These core files establish the application's structure and dependency management.

**MVP Relevance**: All application core components are immediately required for the MVP to function as an Android application.

**Violation if Misplaced**: Moving these components would break Android conventions and make the application structure harder to understand and maintain.

**AI Usability**: Generate application core components that follow Android best practices, using proper lifecycle management and dependency injection patterns.

### src/mobile/webview/

**Purpose**: Contains components for integrating Babylon.js through WebView and bridging between native and web code.

**Justification**: WebView components encapsulate the Babylon.js integration, providing a clean interface between native Android code and web-based 3D rendering.

**MVP Relevance**: All WebView components are immediately required for the MVP's 3D visualization functionality, particularly for garment fit visualization.

**Violation if Misplaced**: Moving WebView components would mix 3D rendering concerns with UI or business logic, complicating the codebase.

**AI Usability**: Generate WebView components that focus on efficiently bridging between native Android and web-based Babylon.js, with robust communication between the two environments. The bridge must support passing anchor measurement data for fit evaluation.

## Babylon Runtime

The Babylon runtime provides reusable modules for 3D rendering that can be used by both the React frontend and potentially other interfaces.

```
src/babylon/
├── core/                     # Core engine components
│   ├── engine.ts             # Babylon engine configuration
│   ├── scene.ts              # Scene management
│   └── camera.ts             # Camera system
├── loaders/                  # Asset loading
│   ├── modelLoader.ts        # GLB model loading
│   ├── textureLoader.ts      # Texture loading
│   └── environmentLoader.ts  # Environment loading
├── rendering/                # Rendering systems
│   ├── materials.ts          # Material system
│   ├── lighting.ts           # Lighting system
│   ├── anchorVisualizer.ts   # Anchor point visualization
│   └── fitFeedback.ts        # Fit status visualization
├── animation/                # Animation systems
│   ├── animationPlayer.ts    # Animation playback
│   ├── avatarAnimator.ts     # Avatar-specific animations
│   └── transitionSystem.ts   # Animation transitions
├── interaction/              # User interaction
│   ├── inputManager.ts       # Input handling
│   ├── cameraController.ts   # Camera movement
│   └── objectInteraction.ts  # Object selection/manipulation
└── utils/                    # Utilities
    ├── math.ts               # Mathematical helpers
    ├── debug.ts              # Debugging tools
    └── optimization.ts       # Performance optimization
```

### src/babylon/rendering/

**Purpose**: Contains systems for visual appearance, including materials, lighting, effects, and fit visualization.

**Justification**: Rendering components handle the visual aspects of the 3D scene, separated by function for clarity.

**MVP Relevance**: All rendering components are immediately required for the MVP's visual quality, with `anchorVisualizer.ts` and `fitFeedback.ts` being crucial for anchor-based fit visualization.

**Violation if Misplaced**: Moving rendering components would mix visual appearance concerns with structural or interaction concerns.

**AI Usability**: Generate rendering components that focus on creating visually appropriate scenes, with special attention to `fitFeedback.ts` for implementing the color-coded visualization based on anchor measurement comparisons.

## Unity Tooling

The Unity tooling provides utilities for garment creation, validation, and anchor point definition with measurement values.

```
src/unity/
├── editor/                   # Unity editor tools
│   ├── GarmentValidator.cs   # Garment validation tool
│   ├── AnchorEditor.cs       # Anchor point editing with measurement values
│   └── ExportTools.cs        # GLB export utilities
├── scenes/                   # Unity scenes
│   ├── GarmentValidation.unity # Validation scene
│   └── AnchorDefinition.unity # Anchor editing scene
├── scripts/                  # Unity scripts
│   ├── models/               # Data models
│   │   ├── GarmentData.cs    # Garment metadata
│   │   └── AnchorData.cs     # Anchor point data with expected measurements
│   ├── components/           # MonoBehaviour components
│   │   └── AnchorMarker.cs   # Visual representation of anchor with measurements
│   ├── validation/           # Validation logic
│   │   ├── MeshValidator.cs  # Mesh quality validation
│   │   └── AnchorValidator.cs # Anchor point validation with measurements
│   └── export/               # Export logic
│       ├── GlbExporter.cs    # GLB file generation
│       └── MetadataExporter.cs # Metadata export including anchor measurements
└── exports/                  # Export templates
    ├── GarmentTemplate.glb   # Base garment template
    └── MetadataTemplate.json # Metadata template with anchor measurements
```

### src/unity/scripts/components/

**Purpose**: Contains MonoBehaviour components for Unity scenes, including anchor point markers with measurement values.

**Justification**: Component scripts provide the core functionality for garment authoring, separated by function for clarity.

**MVP Relevance**: All component scripts are required for the MVP's garment authoring workflow, with `AnchorMarker.cs` being crucial for defining anchor points with expected measurement values.

**Violation if Misplaced**: Moving component scripts would mix different functional concerns, making the codebase less maintainable.

**AI Usability**: Generate Unity component scripts that focus on specific garment-related tasks, following Unity's component-based architecture. `AnchorMarker.cs` should provide UI for inputting and visualizing anchor measurement values.

### src/unity/scripts/export/

**Purpose**: Contains logic for exporting garments and their metadata, including anchor points with expected measurement values.

**Justification**: Export scripts ensure consistent data formats between Unity authoring tools and the runtime application.

**MVP Relevance**: All export scripts are required for the MVP's garment authoring workflow, with `MetadataExporter.cs` being crucial for including anchor measurement values in the exported data.

**Violation if Misplaced**: Moving export scripts would reduce the consistency of the exported data, potentially breaking interoperability.

**AI Usability**: Generate export scripts that focus on creating standardized data formats, ensuring that anchor points include their expected measurement values for fit evaluation.

## Test Architecture

The test architecture mirrors the main source structure, with tests organized by layer and function.

```
tests/
├── backend/                  # Backend tests
│   ├── domain/               # Domain layer tests
│   │   ├── measurement/      # Measurement domain tests
│   │   └── garment/          # Garment domain tests
│   ├── application/          # Application layer tests
│   │   ├── measurement/      # Measurement application tests
│   │   └── garment/          # Garment application tests
│   ├── infrastructure/       # Infrastructure layer tests
│   │   ├── persistence/      # Persistence tests
│   │   ├── services/         # Service tests
│   │   └── simulation/       # Simulation tests with fit evaluation
│   └── api/                  # API layer tests
│       ├── controllers/      # Controller tests
│       └── middleware/       # Middleware tests
├── mobile/                   # Mobile app tests
│   ├── ui/                   # UI component tests
│   ├── domain/               # Domain logic tests
│   ├── network/              # Network API tests
│   └── webview/              # WebView integration tests
└── frontend/                 # Frontend tests
    ├── components/           # Component tests
    │   ├── avatar/           # Avatar component tests
    │   ├── garment/          # Garment component tests
    │   └── ui/               # UI component tests
    ├── hooks/                # Hook tests
    ├── services/             # Service tests
    └── state/                # State store tests
```

### tests/backend/

**Purpose**: Contains tests for the backend components, organized by architectural layer.

**Justification**: Backend tests verify the functionality of the backend components, mirroring the structure of the source code for clarity. They're separated by layer and bounded context.

**MVP Relevance**: Backend tests are immediately required to ensure the quality and correctness of the MVP, with special focus on testing anchor-based fit evaluation.

**Violation if Misplaced**: Moving backend tests would make it harder to locate tests for specific components, reducing test coverage and maintainability.

**AI Usability**: Generate backend tests that focus on verifying the functionality of specific components, using appropriate testing patterns for each layer. Testing fit evaluation logic based on anchor measurements should be prioritized.

### tests/mobile/

**Purpose**: Contains tests for the mobile application, organized by component type.

**Justification**: Mobile tests verify the functionality of the Android application, mirroring the structure of the source code for clarity. They're separated by component type.

**MVP Relevance**: Mobile tests are immediately required to ensure the quality and correctness of the Android MVP.

**Violation if Misplaced**: Moving mobile tests would make it harder to locate tests for specific components, reducing test coverage and maintainability.

**AI Usability**: Generate mobile tests that focus on verifying the functionality of specific components, using appropriate testing patterns for each component type. Tests should cover both UI components and business logic, with special attention to WebView integration for 3D visualization.

## Guidelines for AI Code Generation

When generating code for the TailorCore MVP project, AI models should adhere to the following guidelines:

1. **Respect Layer Boundaries**: Ensure that code adheres to the architectural principles of its layer, particularly for the backend Clean Architecture.
    
2. **Follow Dependency Direction**: In the backend, dependencies should only point inward (from outer layers to inner layers). Domain should have no dependencies on other layers.
    
3. **Maintain Bounded Contexts**: Keep measurement and garment concerns separate unless intentionally integrating them.
    
4. **Use Appropriate Patterns**: Apply CQRS for backend operations, component composition for frontend UI, and entity-component systems for Unity.
    
5. **Follow Naming Conventions**: Use consistent naming patterns within each section of the codebase (e.g., Command/CommandHandler, Query/QueryHandler).
    
6. **Honor Type Safety**: Use strong typing throughout the codebase, with clear interfaces and type definitions.
    
7. **Implement Error Handling**: Include appropriate error handling for each layer, from domain validation to API responses.
    
8. **Focus on MVP Requirements**: Prioritize code that directly supports the MVP scenarios defined in the requirements.
    
9. **Comment Complex Logic**: Include explanatory comments for complex business rules or technical implementations.
    
10. **Ensure Testability**: Design components to be testable, with clear dependencies and interfaces.
    
11. **Implement Anchor-Based Fit Evaluation**: When working with garments and avatars, always include logic for comparing anchor measurements and providing appropriate feedback.
    
12. **Mobile-Native Integration**: For mobile components, ensure proper communication between native code and WebView for 3D visualization.
    
13. **Unity Editor Extensions**: When creating Unity components, provide appropriate editor tools for setting anchor measurements.
    

By following these guidelines, AI-generated code will align with the architectural vision of the TailorCore MVP project while maintaining high quality and consistency.